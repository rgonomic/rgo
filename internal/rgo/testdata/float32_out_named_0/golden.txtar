-- R/float32_out_named_0.R --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

#' @useDynLib float32_out_named_0

#' Test0
#'
#' Test0 does things with [] and returns [float32].
#' 
#' @return A double value, res0
#' @seelso <https://godoc.org/float32_out_named_0#Test0>
#' @export
test_0 <- function() {
	.Call("test_0", PACKAGE = "float32_out_named_0")
}
-- src/Makevars --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

.PHONY: all

CGO_CFLAGS = "$(ALL_CPPFLAGS)"
CGO_LDFLAGS = "$(PKG_LIBS) $(SHLIB_LIBADD) $(LIBR)"

all: go docs

docs:

go:
	rm -f *.h
	CGO_CFLAGS=$(CGO_CFLAGS) CGO_LDFLAGS=$(CGO_LDFLAGS) go pack -o $(SHLIB) -packmode=c-shared float32_out_named_0/src/rgo/float32_out_named_0
-- src/rgo/float32_out_named_0.c --
// Code generated by rgnonomic/rgo; DO NOT EDIT.

#include "_cgo_export.h"

void R_warning(char* s) {
	warning(s);
}

void R_error(char* s) {
	error(s);
}

// TODO(kortschak): Only emit these when needed:
// Needed for unpacking SEXP character.
GoString R_gostring(SEXP x) {
	SEXP _s = STRING_ELT(x, 0);
	GoString s = {(char*)CHAR(_s), STDVEC_LENGTH(_s)};
	return s;
}

// Needed for getting list elements by name.
int getListElementIndex(SEXP list, const char *str) {
	int index = -1;
	SEXP names = getAttrib(list, R_NamesSymbol);
	for (int i = 0; i < length(list); i++) {
		if (strcmp(CHAR(STRING_ELT(names, i)), str) == 0) {
			index = i;
			break;
		}
	}
	return index;
}

SEXP test_0() {
	return Wrapped_Test0();
}
-- src/rgo/float32_out_named_0.go --
// Code generated by rgnonomic/rgo; DO NOT EDIT.

package main

/*
#define USE_RINTERNALS
#include <R.h>
#include <Rinternals.h>

// TODO(kortschak): Only emit these when needed.
extern _GoString_ R_gostring(SEXP x);
*/
import "C"

import (
	"fmt"
	"unsafe"

	"float32_out_named_0"
)


//export Wrapped_Test0
func Wrapped_Test0() C.SEXP {
	defer func() {
		r := recover()
		if r != nil {
			err := C.CString(fmt.Sprint(r))
			C.R_error(err)
			C.free(unsafe.Pointer(err))
		}
	}()

	_r0 := float32_out_named_0.Test0()
	return packSEXP_Test0(_r0)
}

func packSEXP_Test0(res0 float32) C.SEXP {
	return packSEXP_types_Basic_float32(res0)
}

func packSEXP_types_Basic_float32(p float32) C.SEXP {
	return C.ScalarReal(C.double(p))
}

func main() {}
