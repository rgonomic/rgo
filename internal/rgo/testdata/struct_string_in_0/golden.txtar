-- DESCRIPTION --
Package: struct_string_in_0
Title: What the Package Does (One Line, Title Case)
Version: 
Authors@R:
    person(given   = "First",
           family  = "Last",
           role    = c("aut", "cre"),
           email   = "first.last@example.com",
           comment = c(ORCID = "YOUR-ORCID-ID"))
Description: What the package does (one paragraph).
License: See LICENSE directory
Encoding: UTF-8
LazyData: true
-- NAMESPACE --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

useDynLib(struct_string_in_0)
export(test_0)
-- R/struct_string_in_0.R --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

#' @useDynLib struct_string_in_0

#' Test0
#'
#' Test0 does things with [struct{F1 string; F2 string "rgo:\"Rname\""}] and returns [].
#' 
#' @param par0 is a list corresponding to struct{F1 string; F2 string "rgo:\"Rname\""}
#' @seelso <https://godoc.org/struct_string_in_0#Test0>
#' @export
test_0 <- function(par0) {
	if (!is.list(par0)) {
		stop("Argument 'par0' must be of type 'list'.")
	}
	.Call("test_0", par0, PACKAGE = "struct_string_in_0")
}
-- src/Makevars --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

.PHONY: all

CGO_CFLAGS = "$(ALL_CPPFLAGS)"
CGO_LDFLAGS = "$(PKG_LIBS) $(SHLIB_LIBADD) $(LIBR)"

all: go docs

docs:

go:
	rm -f *.h
	CGO_CFLAGS=$(CGO_CFLAGS) CGO_LDFLAGS=$(CGO_LDFLAGS) go build -o $(SHLIB) -buildmode=c-shared ./rgo
-- src/rgo/struct_string_in_0.c --
// Code generated by rgnonomic/rgo; DO NOT EDIT.

#include "_cgo_export.h"

void R_warning(char* s) {
	warning(s);
}

void R_error(char* s) {
	error(s);
}

// TODO(kortschak): Only emit these when needed:
// Needed for unpacking SEXP character.
GoString R_gostring(SEXP x) {
	SEXP _s = STRING_ELT(x, 0);
	GoString s = {(char*)CHAR(_s), STDVEC_LENGTH(_s)};
	return s;
}

// Needed for getting list elements by name.
int getListElementIndex(SEXP list, const char *str) {
	int index = -1;
	SEXP names = getAttrib(list, R_NamesSymbol);
	for (int i = 0; i < length(list); i++) {
		if (strcmp(CHAR(STRING_ELT(names, i)), str) == 0) {
			index = i;
			break;
		}
	}
	return index;
}

SEXP test_0(SEXP par0) {
	return Wrapped_Test0(par0);
}
-- src/rgo/struct_string_in_0.go --
// Code generated by rgnonomic/rgo; DO NOT EDIT.

package main

/*
#define USE_RINTERNALS
#include <R.h>
#include <Rinternals.h>
extern void R_error(char *s);

// TODO(kortschak): Only emit these when needed.
extern Rboolean Rf_isNull(SEXP s);
extern _GoString_ R_gostring(SEXP x);
*/
import "C"

import (
	"fmt"
	"unsafe"

	"struct_string_in_0"
)


//export Wrapped_Test0
func Wrapped_Test0(par0 C.SEXP) C.SEXP {
	defer func() {
		r := recover()
		if r != nil {
			err := C.CString(fmt.Sprint(r))
			C.R_error(err)
			C.free(unsafe.Pointer(err))
		}
	}()

	_p0 := unpackSEXP_types_Struct_struct_F1_string__F2_string__rgo___Rname____(par0)
	struct_string_in_0.Test0(_p0)
	return C.R_NilValue
}


func unpackSEXP_types_Basic_string(p C.SEXP) string {
	return C.R_gostring(p)
}

func unpackSEXP_types_Struct_struct_F1_string__F2_string__rgo___Rname____(p C.SEXP) struct{F1 string; F2 string "rgo:\"Rname\""} {
	switch n := C.Rf_xlength(p); {
	case n < 2:
		panic(`missing list element for struct{F1 string; F2 string "rgo:\"Rname\""}`)
	case n > 2:
		err := C.CString(`extra list element ignored for struct{F1 string; F2 string "rgo:\"Rname\""}`)
		C.R_error(err)
		C.free(unsafe.Pointer(err))
	}
	var r struct{F1 string; F2 string "rgo:\"Rname\""}
	var i C.int
	key_F1 := C.CString("F1")
	defer C.free(unsafe.Pointer(key_F1))
	i = getListElementIndex(p, key_F1)
	if i < 0 {
		panic("no list element for field: F1")
	}
	r.F1 = unpackSEXP_types_Basic_string(C.VECTOR_ELT(p, C.R_xlen_t(i)))
	key_Rname := C.CString("Rname")
	defer C.free(unsafe.Pointer(key_Rname))
	i = getListElementIndex(p, key_Rname)
	if i < 0 {
		panic("no list element for field: F2")
	}
	r.F2 = unpackSEXP_types_Basic_string(C.VECTOR_ELT(p, C.R_xlen_t(i)))
	return r
}

func main() {}
