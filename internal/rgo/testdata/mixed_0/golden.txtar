-- DESCRIPTION --
Package: mixed_0
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0
Authors@R:
    person(given   = "First",
           family  = "Last",
           role    = c("aut", "cre"),
           email   = "first.last@example.com",
           comment = c(ORCID = "YOUR-ORCID-ID"))
Description: What the package does (one paragraph).
License: See LICENSE directory
Encoding: UTF-8
LazyData: true
-- NAMESPACE --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

useDynLib(mixed_0)
export(test_0)
export(test_1)
export(test_2)
export(test_3)
-- R/mixed_0.R --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

#' @useDynLib mixed_0

#' test_0
#'
#' Test0 does things with [int] and returns [int int].
#' 
#' @param par0 is a scalar integer
#' @return A structured value containing:
#' @return - a scalar integer, $r0
#' @return - a scalar integer, $r1
#' @seelso <https://godoc.org/mixed_0#Test0>
#' @export
test_0 <- function(par0) {
	if (!is.integer(par0)) {
		stop("Argument 'par0' must be of type 'integer'.")
	}
	if (length(par0) != 1) {
		stop("Argument 'par0' must have 1 element.")
	}
	.Call("test_0", par0, PACKAGE = "mixed_0")
}

#' test_1
#'
#' Test1 does things with [int] and returns [float64 int].
#' 
#' @param par0 is a scalar integer
#' @return A structured value containing:
#' @return - a scalar double, $res0
#' @return - a scalar integer, $res1
#' @seelso <https://godoc.org/mixed_0#Test1>
#' @export
test_1 <- function(par0) {
	if (!is.integer(par0)) {
		stop("Argument 'par0' must be of type 'integer'.")
	}
	if (length(par0) != 1) {
		stop("Argument 'par0' must have 1 element.")
	}
	.Call("test_1", par0, PACKAGE = "mixed_0")
}

#' test_2
#'
#' Test2 does things with [int] and returns [].
#' 
#' @param par0 is a scalar integer
#' @seelso <https://godoc.org/mixed_0#Test2>
#' @export
test_2 <- function(par0) {
	if (!is.integer(par0)) {
		stop("Argument 'par0' must be of type 'integer'.")
	}
	if (length(par0) != 1) {
		stop("Argument 'par0' must have 1 element.")
	}
	.Call("test_2", par0, PACKAGE = "mixed_0")
}

#' test_3
#'
#' Test3 does things with [T S1] and returns [S1].
#' 
#' @param par0 is a scalar integer
#' @param par1 is a scalar character
#' @return A scalar character
#' @seelso <https://godoc.org/mixed_0#Test3>
#' @export
test_3 <- function(par0, par1) {
	if (!is.integer(par0)) {
		stop("Argument 'par0' must be of type 'integer'.")
	}
	if (length(par0) != 1) {
		stop("Argument 'par0' must have 1 element.")
	}
	if (!is.character(par1)) {
		stop("Argument 'par1' must be of type 'character'.")
	}
	if (length(par1) != 1) {
		stop("Argument 'par1' must have 1 element.")
	}
	.Call("test_3", par0, par1, PACKAGE = "mixed_0")
}
-- src/Makevars --
# Code generated by rgnonomic/rgo; DO NOT EDIT.

.PHONY: all

CGO_CFLAGS = "$(ALL_CPPFLAGS)"
CGO_LDFLAGS = "$(PKG_LIBS) $(SHLIB_LIBADD) $(LIBR)"

all: go docs

docs:

go:
	rm -f *.h
	CGO_CFLAGS=$(CGO_CFLAGS) CGO_LDFLAGS=$(CGO_LDFLAGS) go build -o $(SHLIB) -buildmode=c-shared ./rgo
-- src/rgo/mixed_0.c --
// Code generated by rgnonomic/rgo; DO NOT EDIT.

#include "_cgo_export.h"

void R_warning(char* s) {
	warning(s);
}

void R_error(char* s) {
	error(s);
}

// TODO(kortschak): Only emit these when needed:
// Needed for unpacking SEXP character.
GoString R_gostring(SEXP x, R_xlen_t i) {
	SEXP _s = STRING_ELT(x, i);
	GoString s = {(char*)CHAR(_s), STDVEC_LENGTH(_s)};
	return s;
}

// Needed for getting list elements by name.
int getListElementIndex(SEXP list, const char *str) {
	int index = -1;
	SEXP names = getAttrib(list, R_NamesSymbol);
	for (int i = 0; i < length(list); i++) {
		if (strcmp(CHAR(STRING_ELT(names, i)), str) == 0) {
			index = i;
			break;
		}
	}
	return index;
}

SEXP test_0(SEXP par0) {
	return Wrapped_Test0(par0);
}

SEXP test_1(SEXP par0) {
	return Wrapped_Test1(par0);
}

SEXP test_2(SEXP par0) {
	return Wrapped_Test2(par0);
}

SEXP test_3(SEXP par0, SEXP par1) {
	return Wrapped_Test3(par0, par1);
}
-- src/rgo/mixed_0.go --
// Code generated by rgnonomic/rgo; DO NOT EDIT.

package main

/*
#define USE_RINTERNALS
#include <R.h>
#include <Rinternals.h>
extern void R_error(char *s);

// TODO(kortschak): Only emit these when needed.
extern Rboolean Rf_isNull(SEXP s);
extern _GoString_ R_gostring(SEXP x, R_xlen_t i);
extern int getListElementIndex(SEXP list, const char *str);
*/
import "C"

import (
	"fmt"
	"unsafe"

	"mixed_0"
)


//export Wrapped_Test0
func Wrapped_Test0(_R_par0 C.SEXP) C.SEXP {
	defer func() {
		r := recover()
		if r != nil {
			err := C.CString(fmt.Sprint(r))
			C.R_error(err)
			C.free(unsafe.Pointer(err))
		}
	}()

	_p0 := unpackSEXP_types_Basic_int(_R_par0)
	_r0, _r1 := mixed_0.Test0(_p0)
	return packSEXP_Test0(_r0, _r1)
}

func packSEXP_Test0(p0 int, p1 int) C.SEXP {
	r := C.allocList(2)
	C.Rf_protect(r)
	names := C.Rf_allocVector(C.STRSXP, 2)
	C.Rf_protect(names)
	arg := r
	C.SET_STRING_ELT(names, 0, C.Rf_mkCharLenCE(C._GoStringPtr("r0"), 2, C.CE_UTF8))
	C.SETCAR(arg, packSEXP_types_Basic_int(p0))
	arg = C.CDR(arg)
	C.SET_STRING_ELT(names, 1, C.Rf_mkCharLenCE(C._GoStringPtr("r1"), 2, C.CE_UTF8))
	C.SETCAR(arg, packSEXP_types_Basic_int(p1))
	C.setAttrib(r, packSEXP_types_Basic_string("names"), names)
	C.Rf_unprotect(2)
	return r
}

//export Wrapped_Test1
func Wrapped_Test1(_R_par0 C.SEXP) C.SEXP {
	defer func() {
		r := recover()
		if r != nil {
			err := C.CString(fmt.Sprint(r))
			C.R_error(err)
			C.free(unsafe.Pointer(err))
		}
	}()

	_p0 := unpackSEXP_types_Basic_int(_R_par0)
	_r0, _r1 := mixed_0.Test1(_p0)
	return packSEXP_Test1(_r0, _r1)
}

func packSEXP_Test1(res0 float64, res1 int) C.SEXP {
	r := C.allocList(2)
	C.Rf_protect(r)
	names := C.Rf_allocVector(C.STRSXP, 2)
	C.Rf_protect(names)
	arg := r
	C.SET_STRING_ELT(names, 0, C.Rf_mkCharLenCE(C._GoStringPtr("r0"), 2, C.CE_UTF8))
	C.SETCAR(arg, packSEXP_types_Basic_float64(res0))
	arg = C.CDR(arg)
	C.SET_STRING_ELT(names, 1, C.Rf_mkCharLenCE(C._GoStringPtr("r1"), 2, C.CE_UTF8))
	C.SETCAR(arg, packSEXP_types_Basic_int(res1))
	C.setAttrib(r, packSEXP_types_Basic_string("names"), names)
	C.Rf_unprotect(2)
	return r
}

//export Wrapped_Test2
func Wrapped_Test2(_R_par0 C.SEXP) C.SEXP {
	defer func() {
		r := recover()
		if r != nil {
			err := C.CString(fmt.Sprint(r))
			C.R_error(err)
			C.free(unsafe.Pointer(err))
		}
	}()

	_p0 := unpackSEXP_types_Basic_int(_R_par0)
	mixed_0.Test2(_p0)
	return C.R_NilValue
}


//export Wrapped_Test3
func Wrapped_Test3(_R_par0, _R_par1 C.SEXP) C.SEXP {
	defer func() {
		r := recover()
		if r != nil {
			err := C.CString(fmt.Sprint(r))
			C.R_error(err)
			C.free(unsafe.Pointer(err))
		}
	}()

	_p0 := unpackSEXP_types_Named_mixed_0_T(_R_par0)
	_p1 := unpackSEXP_types_Named_mixed_0_S1(_R_par1)
	_r0 := mixed_0.Test3(_p0, _p1)
	return packSEXP_Test3(_r0)
}

func packSEXP_Test3(p0 mixed_0.S1) C.SEXP {
	return packSEXP_types_Named_mixed_0_S1(p0)
}

func unpackSEXP_types_Basic_int(p C.SEXP) int {
	return int(*C.INTEGER(p))
}

func unpackSEXP_types_Basic_string(p C.SEXP) string {
	return C.R_gostring(p, 0)
}

func unpackSEXP_types_Named_mixed_0_S1(p C.SEXP) mixed_0.S1 {
	return mixed_0.S1(unpackSEXP_types_Basic_string(p))
}

func unpackSEXP_types_Named_mixed_0_T(p C.SEXP) mixed_0.T {
	return mixed_0.T(unpackSEXP_types_Basic_int(p))
}

func packSEXP_types_Basic_float64(p float64) C.SEXP {
	return C.ScalarReal(C.double(p))
}

func packSEXP_types_Basic_int(p int) C.SEXP {
	return C.ScalarInteger(C.int(p))
}

func packSEXP_types_Basic_string(p string) C.SEXP {
	s := C.Rf_mkCharLenCE(C._GoStringPtr(p), C.int(len(p)), C.CE_UTF8)
	return C.ScalarString(s)
}

func packSEXP_types_Named_mixed_0_S1(p mixed_0.S1) C.SEXP {
	return packSEXP_types_Basic_string(string(p))
}

func main() {}
